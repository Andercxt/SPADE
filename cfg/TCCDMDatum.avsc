{
  "type" : "record",
  "name" : "TCCDMDatum",
  "namespace" : "com.bbn.tc.schema.avro",
  "doc" : "* A record representing either a vertex or an edge. This is the top level record that allows\n     * us to easily mix the vertices and edges defined above on the wire.",
  "fields" : [ {
    "name" : "datum",
    "type" : [ {
      "type" : "record",
      "name" : "Subject",
      "doc" : "* Subjects represent execution contexts and include mainly threads and processes.\n     * They can be more granular and can represent other execution boundaries such as\n     * functions and blocks if needed.",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "universally unique identifier for the subject"
      }, {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "SubjectType",
          "doc" : "* SUBJECT_PROCESS,    process\n     * SUBJECT_THREAD,     thread within a process\n     * SUBJECT_UNIT        so far we only know of TRACE BEEP using this",
          "symbols" : [ "SUBJECT_PROCESS", "SUBJECT_THREAD", "SUBJECT_UNIT" ]
        },
        "doc" : "the subject type"
      }, {
        "name" : "source",
        "type" : {
          "type" : "enum",
          "name" : "InstrumentationSource",
          "doc" : "* SOURCE_LINUX_AUDIT_TRACE,          from Linux /dev/audit\n     * SOURCE_LINUX_PROC_TRACE,           from Linux's /proc\n     * SOURCE_FREEBSD_OPENBSM_TRACE,      from FreeBSD openBSM\n     * SOURCE_ANDROID_JAVA_CLEARSCOPE,    from android java instrumentation\n     * SOURCE_ANDROID_NATIVE_CLEARSCOPE,  from android's native instrumentation\n     * SOURCE_LINUX_AUDIT_CADETS          placeholder for now\n     *",
          "symbols" : [ "SOURCE_LINUX_AUDIT_TRACE", "SOURCE_LINUX_PROC_TRACE", "SOURCE_FREEBSD_OPENBSM_TRACE", "SOURCE_ANDROID_JAVA_CLEARSCOPE", "SOURCE_ANDROID_NATIVE_CLEARSCOPE", "SOURCE_LINUX_AUDIT_CADETS" ]
        },
        "doc" : "Where it came from, see InstrumentationSource"
      }, {
        "name" : "startTimestampMicros",
        "type" : "long",
        "doc" : "The start time of the subject"
      }, {
        "name" : "endTimestampMicros",
        "type" : [ "null", "long" ],
        "doc" : "The end time of the subject (Optional)",
        "default" : null
      }, {
        "name" : "pid",
        "type" : [ "null", "int" ],
        "doc" : "OS process id for type process and unit id for a unit (Optional)",
        "default" : null
      }, {
        "name" : "ppid",
        "type" : [ "null", "int" ],
        "doc" : "OS parent process id for type process and pid for type unit (Optional)",
        "default" : null
      }, {
        "name" : "unitId",
        "type" : [ "null", "int" ],
        "doc" : "unit id for unit based instrumentation (Optional)",
        "default" : null
      }, {
        "name" : "cmdLine",
        "type" : [ "null", "string" ],
        "doc" : "Process command line arguments including process name (Optional)",
        "default" : null
      }, {
        "name" : "envVars",
        "type" : [ "null", "string" ],
        "doc" : "Process environment variables (Optional)",
        "default" : null
      }, {
        "name" : "properties",
        "type" : [ "null", {
          "type" : "map",
          "values" : "string"
        } ],
        "doc" : "Arbitrary key, value pairs describing the entity",
        "default" : null
      } ]
    }, {
      "type" : "record",
      "name" : "Event",
      "doc" : "* Events represent actions executed on behalf of subjects. Events could include system calls,\n     * function calls, instruction executions, or even more abstract notions representing a blind execution\n     * such as black boxes that are not instrumented (more shortly). Events are the core entity in the model\n     * and they are the main abstraction for representing information flow between data objects, and subjects.\n     * Events are atomic and immutable.",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "A universally unique identifier for the event"
      }, {
        "name" : "timestampMicros",
        "type" : "long",
        "doc" : "* The time at which the event occurred. Timestamps allow reasoning about order of events\n         *  on a host when the same clock is used.\n         * TODO When different clocks are used on a host or across hosts, we need to also define a clock source\n         * A timestamp stores the number of microseconds from the unix epoch, 1 January 1970 00:00:00.000000 UTC."
      }, {
        "name" : "sequence",
        "type" : "long",
        "doc" : "A logical sequence number for ordering events relative to each other within a subject's execution context"
      }, {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "EventType",
          "doc" : "* These event types correspond to the common system calls. Note that we added a blind event\n     *   EVENT_ACCEPT                     accept a connection on an object\n     *   EVENT_BIND                       bind to a network endpoint object\n     *   EVENT_CHANGE_PRINCIPAL           change the principal associated with the process\n     *   EVENT_CHECK_FILE_ATTRIBUTES      check the file attributes such as permissions\n     *   EVENT_CLOSE                      close an object\n     *   EVENT_CONNECT                    connect to an object\n     *   EVENT_CREATE_OBJECT              create an object\n     *   EVENT_CREATE_THREAD              create a thread subject\n     *   EVENT_EXECUTE                    execute an object\n     *   EVENT_FORK                       fork a process subject\n     *   EVENT_LINK                       link an object to a new name\n     *   EVENT_UNLINK                     unlink a name from an object\n     *   EVENT_MMAP                       memory map an object\n     *   EVENT_MODIFY_FILE_ATTRIBUTES     modify the attributes of a file object\n     *   EVENT_MPROTECT                   change permissions of a memory object\n     *   EVENT_OPEN                       open an object\n     *   EVENT_READ                       read an object\n     *   EVENT_WRITE                      write to an object\n     *   EVENT_SIGNAL                     signal another subject\n     *   EVENT_TRUNCATE                   truncate an object\n     *   EVENT_WAIT                       wait on another subject\n     *   EVENT_BLIND                       blind event for a black boxes that are not instrumented",
          "symbols" : [ "EVENT_ACCEPT", "EVENT_BIND", "EVENT_CHANGE_PRINCIPAL", "EVENT_CHECK_FILE_ATTRIBUTES", "EVENT_CLOSE", "EVENT_CONNECT", "EVENT_CREATE_OBJECT", "EVENT_CREATE_THREAD", "EVENT_EXECUTE", "EVENT_FORK", "EVENT_LINK", "EVENT_UNLINK", "EVENT_MMAP", "EVENT_MODIFY_FILE_ATTRIBUTES", "EVENT_MPROTECT", "EVENT_OPEN", "EVENT_READ", "EVENT_WRITE", "EVENT_SIGNAL", "EVENT_TRUNCATE", "EVENT_WAIT", "EVENT_BLIND" ]
        },
        "doc" : "The type of the event"
      }, {
        "name" : "source",
        "type" : "InstrumentationSource",
        "doc" : "What source system generated this event, see InstrumentationSource"
      }, {
        "name" : "location",
        "type" : [ "null", "long" ],
        "doc" : "Location refers to the location of the data affecting the event\n         *  (e.g., the read offset in the file for the read system call event (Optional)",
        "default" : null
      }, {
        "name" : "size",
        "type" : [ "null", "long" ],
        "doc" : "Size refers to the size of the data affecting the event\n         *  (e.g., the number of bytes read from the file for the read system call event (Optional)",
        "default" : null
      }, {
        "name" : "programPoint",
        "type" : [ "null", "string" ],
        "doc" : "The program point where the event was triggered (e.g., executable and line number), (Optional)",
        "default" : null
      }, {
        "name" : "properties",
        "type" : [ "null", {
          "type" : "map",
          "values" : "string"
        } ],
        "doc" : "Arbitrary key, value pairs describing the entity",
        "default" : null
      } ]
    }, {
      "type" : "record",
      "name" : "Value",
      "doc" : "*  Values are just like objects, except they represent transient data instead of persistent data.\n     *  Values have tags and affect (and are affected by) events.s",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "universally unique identifier for the value"
      }, {
        "name" : "size",
        "type" : "int",
        "doc" : "The size of the value in bytes"
      }, {
        "name" : "integrity",
        "type" : [ "null", {
          "type" : "enum",
          "name" : "IntegrityTag",
          "doc" : "* The integrity tag may be used to specify the initial integrity of an entity,\n     * or to endorse its content after performing appropriate checking/sanitization.",
          "symbols" : [ "INTEGRITY_UNTRUSTED", "INTEGRITY_BENIGN", "INTEGRITY_INVULNERABLE" ]
        } ],
        "doc" : "The integrity tag associated with this value (Optional)",
        "default" : null
      }, {
        "name" : "confidentiality",
        "type" : [ "null", {
          "type" : "enum",
          "name" : "ConfidentialityTag",
          "doc" : "* The confidentiality tag may be used to specify the initial confidentiality of an entity,\n     * or to declassify its content after performing appropriate checking/sanitization.",
          "symbols" : [ "CONFIDENTIALITY_SECRET", "CONFIDENTIALITY_SENSITIVE", "CONFIDENTIALITY_PRIVATE", "CONFIDENTIALITY_PUBLIC" ]
        } ],
        "doc" : "The confidentiality tag associated with this value (Optional)",
        "default" : null
      }, {
        "name" : "properties",
        "type" : [ "null", {
          "type" : "map",
          "values" : "string"
        } ],
        "doc" : "Arbitrary key, value pairs describing the entity",
        "default" : null
      } ]
    }, {
      "type" : "record",
      "name" : "NetFlowObject",
      "doc" : "* Represents a network flow object. Instantiates an AbstractObject.",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "Universally unique identifier for the object"
      }, {
        "name" : "baseObject",
        "type" : {
          "type" : "record",
          "name" : "AbstractObject",
          "doc" : "*  Objects, in general, represent data sources and sinks which could include sockets, files,\n     *  memory, and any data in general that can be an input and/or output to an event.\n     *  This record is intended to be abstract i.e., one should not instantiate an Object\n     *  but rather instantiate one of its sub types File, NetFlow, of Memory",
          "fields" : [ {
            "name" : "permission",
            "type" : [ "null", {
              "type" : "fixed",
              "name" : "SHORT",
              "doc" : "2 bytes fixed type",
              "size" : 2
            } ],
            "doc" : "Permission bits defined over the object (Optional)",
            "default" : null
          }, {
            "name" : "lastTimestampMicros",
            "type" : [ "null", "long" ],
            "doc" : "* The timestamp when the object was last modified (Optional).\n        * A timestamp stores the number of microseconds from the unix epoch, 1 January 1970 00:00:00.000000 UTC.",
            "default" : null
          }, {
            "name" : "source",
            "type" : "InstrumentationSource",
            "doc" : "The source that emitted the object, see InstrumentationSource"
          }, {
            "name" : "integrity",
            "type" : [ "null", "IntegrityTag" ],
            "doc" : "The integrity tag associated with this value (Optional)",
            "default" : null
          }, {
            "name" : "confidentiality",
            "type" : [ "null", "ConfidentialityTag" ],
            "doc" : "The confidentiality tag associated with this value (Optional)",
            "default" : null
          }, {
            "name" : "properties",
            "type" : [ "null", {
              "type" : "map",
              "values" : "string"
            } ],
            "doc" : "Arbitrary key, value pairs describing the entity",
            "default" : null
          } ]
        },
        "doc" : "The base object attributes"
      }, {
        "name" : "srcAddress",
        "type" : "string",
        "doc" : "The ip address of the source host for this flow"
      }, {
        "name" : "srcPort",
        "type" : "int",
        "doc" : "The network port on the source host for this flow"
      }, {
        "name" : "destAddress",
        "type" : "string",
        "doc" : "The ip address of the destination host for this flow"
      }, {
        "name" : "destPort",
        "type" : "int",
        "doc" : "The network port on the destination host for this flow"
      } ]
    }, {
      "type" : "record",
      "name" : "FileObject",
      "doc" : "* Represents a file on the file system. Instantiates an AbstractObject.",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "Universally unique identifier for the object"
      }, {
        "name" : "baseObject",
        "type" : "AbstractObject",
        "doc" : "The base object attributes"
      }, {
        "name" : "url",
        "type" : "string",
        "doc" : "The location of the file absolute path or remote url"
      }, {
        "name" : "version",
        "type" : "int",
        "doc" : "The file version incremented every time the file changes",
        "default" : 1
      }, {
        "name" : "size",
        "type" : [ "null", "long" ],
        "doc" : "The file size in bytes (Optional)",
        "default" : null
      } ]
    }, {
      "type" : "record",
      "name" : "SensorObject",
      "doc" : "* Represents a sensor on the host device. Instantiates an AbstractObject.\n     * This is the most basic representation of a sensor, basically specifying its type only.",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "Universally unique identifier for the object"
      }, {
        "name" : "baseObject",
        "type" : "AbstractObject",
        "doc" : "The base object attributes"
      }, {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "SensorType",
          "doc" : "* The type of a sensor could be base (close to hardware) or composite\n     * See https://source.android.com/devices/sensors/index.html for details\n     * TODO: camera and GPS ideally should be modeled separately to match the Android model. These are rich subsystems",
          "symbols" : [ "SENSOR_ACCELEROMETER", "SENSOR_TEMPERATURE", "SENSOR_GYROSCOPE", "SENSOR_MAGNETIC_FIELD", "SENSOR_HEAR_RATE", "SENSOR_LIGHT", "SENSOR_PROXIMITY", "SENSOR_PRESSURE", "SENSOR_RELATIVE_HUMIDITY", "SENSOR_LINEAR_ACCELERATION", "SENSOR_MOTION", "SENSOR_STEP_DETECTOR", "SENSOR_STEP_COUNTER", "SENSOR_TILT_DETECTOR", "SENSOR_ROTATION_VECTOR", "SENSOR_GRAVITY", "SENSOR_GEOMAGNETIC_ROTATION_VECTOR", "SENSOR_CAMERA", "SENSOR_GPS" ]
        },
        "doc" : "The type of the sensor"
      } ]
    }, {
      "type" : "record",
      "name" : "MemoryObject",
      "doc" : "* Represents a page in memory. Instantiates an AbstractObject.\n     * TODO: is memory really an object (with permissions and so on) or is it a transient data?",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "Universally unique identifier for the object"
      }, {
        "name" : "baseObject",
        "type" : "AbstractObject",
        "doc" : "The base object attributes"
      }, {
        "name" : "pageNumber",
        "type" : "long",
        "doc" : "The memory page number"
      }, {
        "name" : "memoryAddress",
        "type" : "long",
        "doc" : "The location in memory"
      } ]
    }, {
      "type" : "record",
      "name" : "ProvenanceTag",
      "doc" : "* A provenance tag defines source dependence on specific data sources (inputs).\n     * A tag identifier is bound to a source and used by the tracking system to\n     * capture dependence on this source input. In terms of the structure of the provenance tag,\n     * this is still a work in progress. We will opt for a simple representation that is expressive\n     * enough to capture all TA1 data but not too complicated.\n     * TODO: the tagID is a long in this version. It can however be an int  for efficiency on-the-wire\n     * especially since tagExpression is comprised of tagIDs.",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "A unique identifier for a tag expression"
      }, {
        "name" : "tagExpression",
        "type" : "string",
        "doc" : "The tag expression as defined in the tag design doc"
      } ]
    }, {
      "type" : "record",
      "name" : "Principal",
      "doc" : "* A principal is a local user\n    * TODO: extend for second evaluation to include remote principals\n    * TODO: what happens when the user information changes (are we tracking versions?)\n    * TODO: Authentication mechanisms: are TA1s providing that information and how?",
      "fields" : [ {
        "name" : "uid",
        "type" : "long",
        "doc" : "A unique id for the principal"
      }, {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "PrincipalType",
          "doc" : "* The type of principal may be local to the host, or remote users/systems.",
          "symbols" : [ "PRINCIPAL_LOCAL", "PRINCIPAL_REMOTE" ]
        },
        "doc" : "The type of the principal, local by default",
        "default" : "PRINCIPAL_LOCAL"
      }, {
        "name" : "userId",
        "type" : "int",
        "doc" : "The operating system id associated with the user"
      }, {
        "name" : "groupIds",
        "type" : {
          "type" : "array",
          "items" : "int"
        },
        "doc" : "The ids of the groups which this user is part of"
      }, {
        "name" : "source",
        "type" : "InstrumentationSource",
        "doc" : "The source that emitted the Principal record, see InstrumentationSource"
      }, {
        "name" : "properties",
        "type" : [ "null", {
          "type" : "map",
          "values" : "string"
        } ],
        "doc" : "Arbitrary key, value pairs describing the entity",
        "default" : null
      } ]
    }, {
      "type" : "record",
      "name" : "SimpleEdge",
      "doc" : "* Edges in the CDM only connect the entities and do not have attributes of their own.\n     *  In order to make the streaming efficient, the edge specification does not require\n     *  the objects on both ends every time it is streamed/serialized. Instead, we defined\n     *  the edge to be simple, it has a type and it connects two entities each identified by\n     *  a uid each.\n     * Since the different edge types in the current model do not have different properties\n     *  (actually no properties at all), we do not define the different edges as separate\n     *  records at this time.\n     * For example, when streaming a large number of edges having the same from node, the\n     *  from node in all these edges will be represented using the node id instead of having\n     *  to replicate the full node object on the wire.",
      "fields" : [ {
        "name" : "fromUid",
        "type" : "long",
        "doc" : "A unique id of the From entity on the edge"
      }, {
        "name" : "toUid",
        "type" : "long",
        "doc" : "The id of the To entity on the edge"
      }, {
        "name" : "type",
        "type" : {
          "type" : "enum",
          "name" : "EdgeType",
          "doc" : "* The different types of simple edges in the CDM\n     *   EDGE_VALUE_HASTAG                  a value has a tag (when tracking granular provenance)\n     *   EDGE_VALUE_AFFECTS_EVENT           a value affects an event (such as input string or buffer to an event)\n     *   EDGE_EVENT_AFFECTS_VALUE           an event affects a value (such as creating a value)\n     *   EDGE_EVENT_AFFECTS_MEMORY          an event affects a memory object (such as updating a memory location)\n     *   EDGE_EVENT_AFFECTS_FILE            an event affects a file object (such as writing to a file)\n     *   EDGE_EVENT_AFFECTS_NETFLOW         an event affects a netflow object (such as writing to socket)\n     *   EDGE_EVENT_AFFECTS_SUBJECT         an event affects a subject (such as forking a process)\n     *   EDGE_EVENT_HASPARENT_EVENT         a metaevent that represents a set of child atomic events\n     *   EDGE_EVENT_ISGENERATEDBY_SUBJECT   an event is generated by a subject (every event is)\n     *   EDGE_SUBJECT_AFFECTS_EVENT         a subject affects an event (such as when killing a process)\n     *   EDGE_SUBJECT_HASPARENT_SUBJECT     a subject has a parent subject (such as thread has parent process)\n     *   EDGE_SUBJECT_HASTAG                a subject has a tag (TODO: not sure when this will be used)\n     *   EDGE_SUBJECT_HASPRINCIPAL          a subject has a principal (such as a process owned by a user)\n     *   EDGE_SUBJECT_RUNSON                a subject runs on a host (TODO: host not yet modeled)\n     *   EDGE_OBJECT_PREV_VERSION           the previous version of an object, typically used for file versioning\n     *",
          "symbols" : [ "EDGE_VALUE_HASTAG", "EDGE_VALUE_AFFECTS_EVENT", "EDGE_EVENT_AFFECTS_VALUE", "EDGE_EVENT_AFFECTS_MEMORY", "EDGE_EVENT_AFFECTS_FILE", "EDGE_EVENT_AFFECTS_NETFLOW", "EDGE_EVENT_AFFECTS_SUBJECT", "EDGE_EVENT_HASPARENT_EVENT", "EDGE_EVENT_ISGENERATEDBY_SUBJECT", "EDGE_SUBJECT_AFFECTS_EVENT", "EDGE_SUBJECT_HASPARENT_SUBJECT", "EDGE_SUBJECT_HASTAG", "EDGE_SUBJECT_HASLOCALPRINCIPAL", "EDGE_SUBJECT_RUNSON", "EDGE_OBJECT_PREV_VERSION" ]
        },
        "doc" : "The type of the edge, see EdgeType"
      }, {
        "name" : "timestamp",
        "type" : "long",
        "doc" : "* When the edge was created.\n        * Timestamp stores the number of microseconds from the unix epoch, 1 January 1970 00:00:00.000000 UTC."
      }, {
        "name" : "properties",
        "type" : [ "null", {
          "type" : "map",
          "values" : "string"
        } ],
        "doc" : "Arbitrary key, value pairs describing the edge",
        "default" : null
      } ]
    } ]
  } ]
}
